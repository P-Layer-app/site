console.log("script.js loaded and executing!"); // Debugging: First line of script execution

import * as THREE from 'three';

const canvas = document.getElementById('hero-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 5;

// Shaders for the fluid effect
const vertexShader = `
  void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  uniform float u_time;
  uniform vec2 u_resolution;

  void main() {
    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
    vec3 color = vec3(0.0);

    // Simple wave effect for demonstration
    color.r = sin(uv.x * 10.0 + u_time * 0.5) * 0.5 + 0.5;
    color.g = cos(uv.y * 8.0 + u_time * 0.7) * 0.5 + 0.5;
    color.b = sin(uv.x * 12.0 + uv.y * 5.0 + u_time * 0.6) * 0.5 + 0.5;

    gl_FragColor = vec4(color, 1.0);
  }
`;

const geometry = new THREE.PlaneGeometry(10, 10);
const material = new THREE.ShaderMaterial({
  vertexShader,
  fragmentShader,
  uniforms: {
    u_time: { value: 0 },
    u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
  },
});

const plane = new THREE.Mesh(geometry, material);
scene.add(plane);

// Handle window resizing
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  material.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
}
window.addEventListener('resize', onWindowResize);

// Animation loop
function animate() {
  requestAnimationFrame(animate);

  material.uniforms.u_time.value += 0.01;

  renderer.render(scene, camera);
}
animate();

// Main DOM content loaded logic
document.addEventListener('DOMContentLoaded', () => {
  console.log("DOMContentLoaded fired in script.js"); // Debugging: Confirm script execution

  // --- Scroll Reveal Logic ---
  const scrollRevealElements = document.querySelectorAll('.scroll-reveal');

  const observerOptions = {
    root: null,
    rootMargin: '0px',
    threshold: 0.1
  };

  const observer = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('is-visible');
        observer.unobserve(entry.target);
      }
    });
  }, observerOptions);

  scrollRevealElements.forEach(el => observer.observe(el));

  // --- Logo Dynamic Animation Logic ---
  const logoContainer = document.querySelector('.logo-container');
  const header = document.querySelector('.header');
  console.log('Logo Container Element:', logoContainer); // Debugging: Check if element is found
  console.log('Header Element:', header); // Debugging: Check if element is found

  if (logoContainer && header) {
    let logoX, logoY, logoVX, logoVY, logoRotation, logoVR;
    let headerWidth, headerHeight, logoSize;
    let isInteracting = false; // Флаг для отслеживания взаимодействия

    const initializeLogoState = () => {
      headerWidth = header.offsetWidth;
      headerHeight = header.offsetHeight;
      logoSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--logo-size'));

      // Debugging: Log dimensions
      console.log('Header Dimensions (init):', headerWidth, headerHeight);
      console.log('Logo Size (init):', logoSize);

      // Ensure initial position is within bounds
      logoX = Math.random() * (headerWidth - logoSize);
      logoY = Math.random() * (headerHeight - logoSize);

      // Fixed initial speeds for clear visibility
      logoVX = (Math.random() - 0.5) * 2 * 2; // -2 to 2 px/frame
      logoVY = (Math.random() - 0.5) * 2 * 1.5; // -1.5 to 1.5 px/frame
      logoRotation = Math.random() * 360;
      logoVR = (Math.random() - 0.5) * 2 * 0.8; // -0.8 to 0.8 deg/frame

      // Apply initial position
      logoContainer.style.transform = `translate(${logoX}px, ${logoY}px) rotate(${logoRotation}deg)`;
    };

    initializeLogoState();

    // Recalculate dimensions on resize
    window.addEventListener('resize', () => {
      initializeLogoState();
      console.log('Resized: Header Dimensions:', header.offsetWidth, header.offsetHeight);
    });

    const updateLogoPosition = () => {
      if (!isInteracting) {
        // Update position
        logoX += logoVX;
        logoY += logoVY;
        logoRotation += logoVR;

        // Boundary collision and bounce
        if (logoX <= 0 || logoX >= headerWidth - logoSize) {
          logoVX *= -1; // Reverse horizontal velocity
          logoX = Math.max(0, Math.min(logoX, headerWidth - logoSize)); // Prevent sticking
          logoVR += (Math.random() - 0.5) * 5; // Random rotation change on bounce
        }
        if (logoY <= 0 || logoY >= headerHeight - logoSize) {
          logoVY *= -1; // Reverse vertical velocity
          logoY = Math.max(0, Math.min(logoY, headerHeight - logoSize)); // Prevent sticking
          logoVR += (Math.random() - 0.5) * 5; // Random rotation change on bounce
        }
      }
      // Apply transform
      logoContainer.style.transform = `translate(${logoX}px, ${logoY}px) rotate(${logoRotation}deg)`;

      requestAnimationFrame(updateLogoPosition);
    };

    updateLogoPosition();

    // --- Mouse Interaction Logic ---
    let interactionTimeout;
    const interactiveTransformDuration = 150; // ms

    const applyInteractiveTransform = (scale, rotate, translateX, translateY) => {
      const currentTransform = logoContainer.style.transform;
      logoContainer.style.transition = `transform ${interactiveTransformDuration}ms ease-out`;
      // Apply relative to current JS-controlled position
      logoContainer.style.transform = `translate(${logoX + translateX}px, ${logoY + translateY}px) scale(${scale}) rotate(${logoRotation + rotate}deg)`;
    };

    const resetInteractiveTransform = () => {
      logoContainer.style.transition = `transform ${interactiveTransformDuration}ms ease-in`;
      logoContainer.style.transform = `translate(${logoX}px, ${logoY}px) rotate(${logoRotation}deg)`;
    };

    logoContainer.addEventListener('mouseenter', () => {
      console.log('mouseenter event');
      isInteracting = true;
      clearTimeout(interactionTimeout);
      applyInteractiveTransform(1.1, 10, (Math.random() - 0.5) * logoSize * 0.5, (Math.random() - 0.5) * logoSize * 0.5); // Nudge and scale
    });

    logoContainer.addEventListener('mouseleave', () => {
      console.log('mouseleave event');
      interactionTimeout = setTimeout(() => {
        resetInteractiveTransform();
        isInteracting = false; // Allow background animation to resume
      }, interactiveTransformDuration); // Wait for transition to finish
    });

    logoContainer.addEventListener('click', (e) => {
      console.log('click event');
      e.preventDefault();
      isInteracting = true;
      clearTimeout(interactionTimeout);

      applyInteractiveTransform(1.2, 45, (Math.random() - 0.5) * logoSize * 1.5, (Math.random() - 0.5) * logoSize * 1.5); // Stronger nudge and scale

      interactionTimeout = setTimeout(() => {
        resetInteractiveTransform();
        isInteracting = false; // Allow background animation to resume
      }, interactiveTransformDuration + 100); // Slightly longer for click effect
    });
  }
});